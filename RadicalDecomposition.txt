// This program performs the Magma computations to check that the two schemes T and S are the same over Z[1/2].

// The Magma computations are performed over Rationals() but later the results are checked to be in fact over Z[1/2].
F:=RationalField();

// Define a polynomial ring in 25 variables (assuming \Phi_1 is 0 and p variables have been eliminated): here, \Phi is denoted d.  
R<q11,q12,
d21,d22,d23,q21,q22,
d31,d32,d33,q31,q32,
d41,d42,d43,q41,q42,
p11,p12,
p21,p22,
p31,p32,
p41,p42>
:=PolynomialRing(F,25);

// Constructs the ideal I which gives T^E (when E = 0) and ideal J which gives T^F.
function construct_ideal_I();

// Assume D_1 (denoted \Phi_1 in the paper) is zero so reduces number of variables by 3.
d11:=0;
d12:=0;
d13:=0;

I:=ideal<R|
2*q21*d11 + q22*d13 - 2*q11*d21 - q12*d23, 2*q22*d12 + q21*d13 - 2*q12*d22 - q11*d23, 2*q31*d11 + q32*d13 - 2*q11*d31 - q12*d33, 2*q32*d12 + q31*d13 - 2*q12*d32 - q11*d33, 
  2*q41*d11 + q42*d13 - 2*q11*d41 - q12*d43, 2*q42*d12 + q41*d13 - 2*q12*d42 - q11*d43, 2*q31*d21 + q32*d23 - 2*q21*d31 - q22*d33, 2*q32*d22 + q31*d23 - 2*q22*d32 - q21*d33, 
  2*q41*d21 + q42*d23 - 2*q21*d41 - q22*d43, 2*q42*d22 + q41*d23 - 2*q22*d42 - q21*d43, 2*q41*d31 + q42*d33 - 2*q31*d41 - q32*d43, 2*q42*d32 + q41*d33 - 2*q32*d42 - q31*d43>;


// Numerator of consistency term (generated by ConsistencyCheck.nb).
E1:=(-q12)*q21 + q11*q22 - q32*q41 + q31*q42 + q22*q31^2*q41*d11 - q21^2*q32*q41*d11 - q22*q31*q41^2*d11 + q21*q32*q41^2*d11 + q21^2*q31*q42*d11 - q21*q31^2*q42*d11 - q22^2*q32*q41*d12 + 
  q22*q32^2*q41*d12 + q22^2*q31*q42*d12 - q21*q32^2*q42*d12 - q22*q31*q42^2*d12 + q21*q32*q42^2*d12 - q21*q22*q32*q41*d13 + q22*q31*q32*q41*d13 + q21*q22*q31*q42*d13 - q21*q31*q32*q42*d13 - 
  q22*q31*q41*q42*d13 + q21*q32*q41*q42*d13 - q12*q31^2*q41*d21 + q11^2*q32*q41*d21 + q12*q31*q41^2*d21 - q11*q32*q41^2*d21 - q11^2*q31*q42*d21 + q11*q31^2*q42*d21 + q12^2*q32*q41*d22 - 
  q12*q32^2*q41*d22 - q12^2*q31*q42*d22 + q11*q32^2*q42*d22 + q12*q31*q42^2*d22 - q11*q32*q42^2*d22 + q11*q12*q32*q41*d23 - q12*q31*q32*q41*d23 - q11*q12*q31*q42*d23 + q11*q31*q32*q42*d23 + 
  q12*q31*q41*q42*d23 - q11*q32*q41*q42*d23 + q12*q21^2*q41*d31 - q11^2*q22*q41*d31 - q12*q21*q41^2*d31 + q11*q22*q41^2*d31 + q11^2*q21*q42*d31 - q11*q21^2*q42*d31 - q12^2*q22*q41*d32 + 
  q12*q22^2*q41*d32 + q12^2*q21*q42*d32 - q11*q22^2*q42*d32 - q12*q21*q42^2*d32 + q11*q22*q42^2*d32 - q11*q12*q22*q41*d33 + q12*q21*q22*q41*d33 + q11*q12*q21*q42*d33 - q11*q21*q22*q42*d33 - 
  q12*q21*q41*q42*d33 + q11*q22*q41*q42*d33 - q12*q21^2*q31*d41 + q11^2*q22*q31*d41 + q12*q21*q31^2*d41 - q11*q22*q31^2*d41 - q11^2*q21*q32*d41 + q11*q21^2*q32*d41 + q12^2*q22*q31*d42 - 
  q12*q22^2*q31*d42 - q12^2*q21*q32*d42 + q11*q22^2*q32*d42 + q12*q21*q32^2*d42 - q11*q22*q32^2*d42 + q11*q12*q22*q31*d43 - q12*q21*q22*q31*d43 - q11*q12*q21*q32*d43 + q11*q21*q22*q32*d43 + 
  q12*q21*q31*q32*d43 - q11*q22*q31*q32*d43;


// Denominator of consistency term.
F1 := - q32*q41 + q31*q42;

return I + ideal<R | E1>, I + ideal<R | F1>;
end function;


// The ideal of polynomial conditions to be semi-Clifford.
J:=ideal<R |
d31*d42-d32*d41,
d31*d43-d33*d41,
d32*d43-d33*d42
>;

// I1 is the ideal which gives T^E.
// I2 is the ideal which gives T^F.
I1,I2:=construct_ideal_I();

// K1 is the ideal which gives S^F.
// K2 is the ideal which gives S^F.
K1:=I1+J;
K2:=I2+J;


// Perform a probable radical decomposition of T^E.
T1:=ProbableRadicalDecomposition(I1);


// Perform a probable radical decomposition of S^E.
S1:=ProbableRadicalDecomposition(K1);


// Check if an ideal I matches an ideal in the list L, return it if so.
function matches(I,L);
for j:=1 to #L do
  if I eq L[j] then
    return true, L[j];
  end if;
end for;
return false,R;
end function;



// Sort S1 and T1 so the first three components match the first three components of S1, respectively.
T1_first:=[];
T1_last:=[];
S1_temp:=[];
for i:=1 to #T1 do
  flag,I:=matches(T1[i],S1);
  if flag then
    T1_first:=Append(T1_first,T1[i]);
    S1_temp:=Append(S1_temp,I);
  else
    T1_last:=Append(T1_last,T1[i]);
  end if;
end for;
T1:=T1_first cat T1_last;
S1:=S1_temp;


// First three components of T^E and S^E respectively, match over Rationals().
assert S1[1] eq T1[1];
assert S1[2] eq T1[2];
assert S1[3] eq T1[3];

[Dimension(X) : X in T1];
[Dimension(X) : X in S1];


// Perform a probable radical decomposition of T^F.
T2:=ProbableRadicalDecomposition(I2);


// Perform a probable radical decomposition of S^F.
S2:=ProbableRadicalDecomposition(K2);




// Sort S2 and T2 so the first three components match the first three components of S2, respectively.
T2_first:=[];
T2_last:=[];
S2_temp:=[];
for i:=1 to #T2 do
  flag,I:=matches(T2[i],S2);
  if flag then
    T2_first:=Append(T2_first,T2[i]);
    S2_temp:=Append(S2_temp,I);
  else
    T2_last:=Append(T2_last,T2[i]);
  end if;
end for;
T2:=T2_first cat T2_last;
S2:=S2_temp;


// First three components of T^F and S^F, respectively, match over Rationals().
assert S2[1] eq T2[1];
assert S2[2] eq T2[2];
assert S2[3] eq T2[3];

[Dimension(X) : X in T2];
[Dimension(X) : X in S2];


// The extraneous components for E = 0 and F = 0 are in fact the same.
// Note the ordering of components chosen by Magma may vary so the 4th and 5th components may be swapped compared to the text.
assert ((T1[4] eq T2[4]) and (T1[5] eq T2[5])) or ((T1[4] eq T2[5]) and (T1[5] eq T2[4]));

RZ:=PolynomialRing(Integers(),25);

// Given a polynomial f over Q, scale it so it has coefficients over Z.
function make_integral(f);

  M:=Maximum([Denominator(c) : c in Coefficients(f)]);
  
  return RZ!(M*f);
end function;

// Given an ideal over Q, scale its generators so they have coefficients in Z.
function convert_integral(I);
  GI:=[make_integral(f) : f in Generators(I)];

  return ideal<RZ | GI>;
end function;

// Given an ideal over Z, convert it into an ideal over Rationals().
function convert_rational(I);
  GI:=[R!f : f in Generators(I)];

  return ideal<R | GI>;
end function;

// Check if denominator the coefficients of the polynomials in L is bounded by 32.
function is_integral(L);
  C:= [Coefficients(f) : f in L];
  D:= &cat C;
  
  for c in D do
    if 32*c notin Integers() then
      return false;
    end if;
  end for;
  return true;
end function;


// Check if two ideals over Rationals() are integrally related over Z[1/2].
function is_integrally_related(I,J);
CI:=[];

for f in Generators(I) do
   CX:=Coordinates(J,f);
   if not is_integral(CX) then
     CI:=Append(CI,CX);
   end if;   
end for;

for g in Generators(J) do
   CX:=Coordinates(I,g);
   if not is_integral(CX) then
     CI:=Append(CI,CX);
   end if;   
end for;

return CI eq [];
end function;


// Check the primary decompositions computed by Magma over Rationals() are in fact over Z[1/2].

T11:=convert_integral(T1[1]);
T12:=convert_integral(T1[2]);
T13:=convert_integral(T1[3]);
T14:=convert_integral(T1[4]);
T15:=convert_integral(T1[5]);
T1A:=T11 meet T12 meet T13 meet T14 meet T15;
assert is_integrally_related(convert_rational(T1A),I1);

S11:=convert_integral(S1[1]);
S12:=convert_integral(S1[2]);
S13:=convert_integral(S1[3]);
S1A:=S11 meet S12 meet S13;
assert is_integrally_related(convert_rational(S1A),K1);

T21:=convert_integral(T2[1]);
T22:=convert_integral(T2[2]);
T23:=convert_integral(T2[3]);
T24:=convert_integral(T2[4]);
T25:=convert_integral(T2[5]);
T2A:=T21 meet T22 meet T23 meet T24 meet T25;
assert is_integrally_related(convert_rational(T2A),I2);

S21:=convert_integral(S2[1]);
S22:=convert_integral(S2[2]);
S23:=convert_integral(S2[3]);
S2A:=S21 meet S22 meet S23;
assert is_integrally_related(convert_rational(S2A),K2);


// Check the components match over Z[1/2]

// First three components of T^E and S^E, respectively, match over Z[1/2].
assert is_integrally_related(S1[1], T1[1]);
assert is_integrally_related(S1[2], T1[2]);
assert is_integrally_related(S1[3], T1[3]);


// First three components of T^F and S^F, respectively, match over Z[1/2].
assert is_integrally_related(S2[1], T2[1]);
assert is_integrally_related(S2[2], T2[2]);
assert is_integrally_related(S2[3], T2[3]);




// Output the ideals T1, S1, T2, S2.
SetLogFile("RadicalOutput2.txt": Overwrite:=true);
T1;
S1;
T2;
S2;
UnsetLogFile();








